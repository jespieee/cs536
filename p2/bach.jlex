import java_cup.runtime.*; // defines the Symbol class

// The generated scanner will return a Symbol for each token that it finds.
// A Symbol contains an Object field named value; that field will be of type
// TokenVal, defined below.
//
// A TokenVal object contains the line number on which the token occurs as
// well as the number of the character on that line that starts the token.
// Some tokens (literals and IDs) also include the value of the token.
  
class TokenVal {
    // fields
    int lineNum;
    int charNum;

    // constructor
    TokenVal(int lineNum, int charNum) {
        this.lineNum = lineNum;
        this.charNum = charNum;
    }
}
  
class IntLitTokenVal extends TokenVal {
    // new field: the value of the integer literal
    int intVal;

    // constructor
    IntLitTokenVal(int lineNum, int charNum, int intVal) {
        super(lineNum, charNum);
        this.intVal = intVal;
    }
}
  
class IdTokenVal extends TokenVal {
    // new field: the value of the identifier
    String idVal;

    // constructor
    IdTokenVal(int lineNum, int charNum, String idVal) {
        super(lineNum, charNum);
        this.idVal = idVal;
    }
}
  
class StrLitTokenVal extends TokenVal {
    // new field: the value of the string literal
    String strVal;

    // constructor
    StrLitTokenVal(int lineNum, int charNum, String strVal) {
        super(lineNum, charNum);
        this.strVal = strVal;
    }
}
  
// The following class is used to keep track of the character number at 
// which the current token starts on its line.
class CharNum {
    static int num = 1;
}
%%

DIGIT=        [0-9]
WHITESPACE=   [\040\t]
LETTER=       [a-zA-Z]
ID=           {LETTER}({LETTER}|{DIGIT}|_)*
NEWLINE=      \n
STRING_CHAR=  [^\"\\\n]
ESCAPED_CHAR= \\\\|\\n|\\s|\\t|\'|\"  

%implements java_cup.runtime.Scanner
%function next_token
%type java_cup.runtime.Symbol

%eofval{
return new Symbol(sym.EOF);
%eofval}

%line

%%

{DIGIT}+  {
            Symbol S = null;
            try {
                int val = Integer.parseInt(yytext());
                S = new Symbol(sym.INTLIT,
                            new IntLitTokenVal(yyline+1, CharNum.num, val));
            } catch (Exception e) {
                ErrMsg.warn(yyline+1, CharNum.num, 
                            "using max integer value: literal too large");
                S = new Symbol(sym.INTLIT, 
                            new IntLitTokenVal(yyline+1, CharNum.num, Integer.MAX_VALUE));
            }
            CharNum.num += yytext().length();
            return S;
          }

{ID}      { 
            CharNum.num += yytext().length(); 
            return new Symbol(sym.ID, new IdTokenVal(yyline+1, CharNum.num, yytext()));
          }

{NEWLINE} { CharNum.num = 1; }

{WHITESPACE}+  { CharNum.num += yytext().length(); }

"="       { Symbol S = new Symbol(sym.ASSIGN, new TokenVal(yyline+1, CharNum.num));
            CharNum.num++;
            return S;
          }

\"({STRING_CHAR}|{ESCAPED_CHAR})*\" {
    // Check for unterminated string literal
    if (yytext().charAt(yytext().length() - 1) != '"') {
        ErrMsg.warn(yyline+1, CharNum.num, "ignoring string literal: unterminated");
        CharNum.num += yytext().length();
        return null;
    }

    // Check for bad escaped characters
    if (yytext().contains("\\") && !yytext().matches("\"({STRING_CHAR}|{ESCAPED_CHAR})*\"")) {
        if (yytext().contains("\n")) {
            ErrMsg.warn(yyline+1, CharNum.num, "ignoring string literal: contains bad escaped character and unterminated");
        } else {
            ErrMsg.warn(yyline+1, CharNum.num, "ignoring string literal: contains bad escaped character");
        }
        CharNum.num += yytext().length();
        return null;
    }

    // Valid string literal
    Symbol S = new Symbol(sym.STRLIT, new StrLitTokenVal(yyline+1, CharNum.num, yytext().substring(1, yytext().length() - 1)));
    CharNum.num += yytext().length();
    return S;
}

.         { ErrMsg.fatal(yyline+1, CharNum.num,
                         "ignoring illegal character: " + yytext());
            CharNum.num++;
          }
